/**
 * «mobileSimbirsoft Platform».
 * Интеллектуальная собственность ООО «Мобайл СимбирСофт».
 * Copyright © 2017 by «Мобайл СимбирСофт».
 */

'use strict';

const co = require('co');

const AFError = require('./Error');
const OAuth = require('./auth/OAuth');
const OAuth2 = require('./auth/OAuth2');
const LDAP = require('./auth/LDAP');
const Facebook = require('./auth/Facebook');
const VK = require('./auth/VK');
const OK = require('./auth/OK');
const User = require('./User');
const Role = require('./Role');

const symbols = {};
const sym = (name) => (symbols[name] || (symbols[name] = Symbol(name)));

class Auth {
  static get types() { return { OAuth, LDAP }; }

  static register(req, options) {
    return co(function* () {
      options = options || {};
      options.methods = options.methods || {};

      if (req.params.register_method == 'basic' || !req.params.register_method) {
        return Auth.registerMethods.basic(req, options);
      }

      if (req.params.register_method && options.methods[req.params.register_method]) {
        if (options.methods[req.params.register_method].type &&
            options.methods[req.params.register_method].type == 'basic') {
          return Auth.registerMethods.basic(req, options.methods[req.params.register_method]);
        }

        let entities = {
          Entity: require('./Entity'),
          Table: require('./Table'),
          Service: require('./Service'),
          Script: require('./Script'),
        };

        let ent = yield entities.Entity.fetch(options.methods[req.params.register_method].entity, null, req.application);

        if (!ent) throw new AFError(500, 'Entity not found');
        ent = new entities[ent.type](ent);

        return Auth.registerMethods[ent.type](req, options.methods[req.params.register_method], ent);
      }

      throw new AFError(400, 'Register method not found');
    }.bind(this));
  }

  static get registerMethods() {
    return {
      basic: (req, options) => {
        if (req.request && req.request.fields) req.body = req.request.fields;
        if (!req.body.username || !req.body.password) {
          throw new AFError(400, 'Username and password are required for basic register');
        }

        if (options.close) {
          throw new AFError(403, 'Register is forbidden');
        }

        let role = options.role || options.defaultRole;

        let user = new User({
          username: req.body.username,
          password: User.cryptPassword(req.body.password),
          role: role
        }, req.application ? req.application.id : null);

        return user.save();
      },

      Service: (req, options, service) => {
        return service.setData(req.body).request(options.route, req)
          .then(data => data.statusCode == 200 ? data.body :
            Promise.reject(new AFError(data.statusCode, data.body)));
      },

      Script: (req, options, script) => {
        script.data = req.request.fields;
        script.req = req;
        return script.run()
          .then(data => data instanceof Error ? Promise.reject(new AFError(data)) : data);
      },
    };
  }

  static authorize(req) {
    return co(function* () {
      req.isAuthorised = false;

      let options = {};

      if (req.application) {
        options = req.application.options ? req.application.options.auth : {};
      }

      // options = Object.assign({ oauth: config.oauth, ldap: config.ldap }, options);

      // options перезатираются блок ниже нужно закинуть перед условием с req.application

      options = {
        oauth: {
          accessTokenLifetime: 60 * 60 * 24,
          refreshTokenLifetime: 60 * 60 * 24 * 7,
        }
      };

      try {
        yield Auth.auth.oauth(req, options)
          .catch(err => Auth.auth.ldap(req, options))        
      } catch (e) {
        throw new AFError(403, 'Permission denied');
      }

      req.user = req.user ? (new User(req.user, req.application)) : undefined;
      req.role = req.user && req.user.role ? (new Role(req.user.role, req.application)) : undefined;
    }.bind(this));
  }

  static fixDollarSign(obj) {
    Object.keys(obj).map((k) => {
      if (k.indexOf("_DS_") + 1) {
        let nk = k.replace("_DS_", "$");
        Object.defineProperty(obj, nk, Object.getOwnPropertyDescriptor(obj, k));
        delete obj[k];
        if (typeof obj[nk] == 'object') {
          Auth.fixDollarSign(obj[nk]);
        }
      }
      if (typeof obj[k] == 'object') {
        Auth.fixDollarSign(obj[k]);
      }
    });
  };

  static checkAccess(entity, access) {
    return req => {
      req.getFilter = req.getFilter || function (query) {
        let filter = {};
        this.filters = this.filters || [];
        if (this.filters.length) {
          Auth.fixDollarSign(this.filters[0].$or[0]);
        }
        filter = { $and: this.filters.concat([query]) };
        if (this.publicFilter) filter = { $or: [this.publicFilter, filter] };
        if (this.importantFilters && this.importantFilters.length) {
          this.importantFilters.push(filter);
          filter = { $and: this.importantFilters };
        }
        return filter;
      };

      req.getFilterSelect = req.getFilterSelect || function (select) {
        let result = [];
        if (!this.select) return select;
        if (!select) return this.select;
        if (Array.isArray(select)) {
          select.filter(s => {
            if (this.select.indexOf(s) >= 0) {
              result.push(s);
            }
          })
        } else {
          if (this.select.indexOf(select) >= 0) {
            result.push(select);
          }
        }
        if (!result.length) return this.select;
        return result;
      };

      let entObj;
      let entName;

      let models = {
        application: require('./Application.js'),
        user: require('./User.js'),
        role: require('./Role.js'),
        entity: require('./Entity.js'),
        log: require('./Log.js'),
      };

      entObj = req[entity] || models[entity];
      if (['application', 'user', 'role', 'entity', 'log'].indexOf(entity) >= 0) entName = 'sys_' + entity;
      else entName = entObj.name;

      if (!entObj) {
        throw new AFError(403, 'Permission denied');
      }

      let publicAccess = entObj.validatePermission('public', access, Object.assign({}, req));
      if (publicAccess) {
        req.publicFilter = typeof publicAccess == 'object' ? publicAccess.filter : undefined;
        req.select = typeof publicAccess == 'object' ? publicAccess.select : undefined;
      }

      if (!req.isAuthorised) {
        if (publicAccess) return;
        throw new AFError(401, 'Unauthorized');
      }

      if (!req.user || !req.user.role) {
        return;
      }

      let userPerms = req.user.role.permissions || {};

      if (!userPerms[entName] && !userPerms.all) {
        if (publicAccess) return;
        throw new AFError(403, 'Permission denied');
      }

      let check = false;
      let filters = [];
      let importantFilters = [];
      let selects = [];

      for (let i = 0; i < 2; i++) {
        let p = [entName, 'all'][i];

        if (userPerms[p]) {
          for (let k in userPerms[p]) {
            let userPerm = userPerms[p][k];

            let v = entObj.validatePermission(k, access, Object.assign({}, req));

            if (!v) { continue; }

            if (userPerm.indexOf(access) > -1) {
              if (v.filter) v.important ? importantFilters.push(v.filter) : filters.push(v.filter);
              if (v.select) selects = selects.concat(v.select);
              check = true;
            }
          }
        }
      }

      if (filters.length) {
        req.filters = req.filters || [];
        req.filters.push({ $or: filters });
      }

      if (importantFilters.length) {
        req.importantFilters = req.importantFilters || [];
        req.importantFilters = req.importantFilters.concat(importantFilters);
      }

      if (selects.length) {
        req.select = (req.select || []).concat(selects);
        req.select = req.select.filter((s, p) => req.select.indexOf(s) == p);
      }

      if (!check) {
        if (publicAccess) return;
        throw new AFError(403, 'Permission denied');
      }

      return;
    };
  }

  static get auth() {
    return {
      oauth: (req, options) => {
        if (!options.oauth) {
          return Promise.reject(new AFError(403, 'OAuth disabled'));
        }

        var oauth = new OAuth(options.oauth);

        return oauth.setReq(req).auth()
          .then(() => req.isAuthorised = true);
      },

      ldap: (req, options) => {
        if (!options.ldap || options.oauth) {
          return Promise.reject(new AFError(403, 'LDAP disabled'));
        }

        if (userData.username && userData.password) {
          var ldap = new LDAP(options.ldap);

          return ldap.setReq(req).auth()
            .then(() => req.isAuthorised = true);
        }

        return Promise.reject(new AFError(400, 'Username and password are required for LDAP'));
      },

      facebook: (req, options) => {
        if (!options.facebook) {
          return Promise.reject(new AFError(403, 'Facebook disabled'));
        }

        var facebook = new Facebook(options.facebook);

        return facebook.setReq(req).auth()
          .then(() => req.isAuthorised = true);
      },

      vk: (req, options) => {
        if (!options.vk) {
          return Promise.reject(new AFError(403, 'VK disabled'));
        }

        var vk = new VK(options.vk);

        return vk.setReq(req).auth()
          .then(() => req.isAuthorised = true);
      },

      ok: (req, options) => {
        if (!options.vk) {
          return Promise.reject(new AFError(403, 'Facebook disabled'));
        }

        var vk = new VK(options.vk);

        return vk.setReq(req).auth()
          .then(() => req.isAuthorised = true);
      },
    };
  }

  static getAuthCode(req, options, params) {
    return co(function* () {
      if (!options.oauth) {
        throw new AFError(403, 'OAuth disabled');
      }

      let oauth = new OAuth2(options.oauth);

      return oauth.getAuthCode(params.authCode);
    }.bind(this));
  }

  static doAuthCodeTrying(req, options, params, limit) {
    return co(function* () {
      if (!options.oauth) {
        throw new AFError(403, 'OAuth disabled');
      }

      let oauth = new OAuth2(options.oauth);

      return oauth.doAuthCodeTrying(params.authCode, limit);
    }.bind(this));
  }

  static getAllAuthCodes(req, options, params) {
    return co(function* () {
      if (!options.oauth) {
        throw new AFError(403, 'OAuth disabled');
      }

      let oauth = new OAuth2(options.oauth);

      return oauth.getAllAuthCodes(params);
    }.bind(this));
  }

  static get login() {
    return {
      oauth: (req, options) => {
        return co(function* () {
          if (!options.oauth) {
            throw new AFError(403, 'OAuth disabled');
          }

          var oauth = new OAuth(options.oauth);

          return oauth.setReq(req).login();
        }.bind(this));
      },

      oauth2auth: (req, options) => {
        return co(function* () {
          if (!options.oauth) {
            throw new AFError(403, 'OAuth disabled');
          }

          var oauth = new OAuth2(options.oauth);

          return oauth.setReq(req).auth();
        }.bind(this));
      },

      oauth2login: (req, options) => {
        return co(function* () {
          if (!options.oauth) {
            throw new AFError(403, 'OAuth disabled');
          }

          var oauth = new OAuth2(options.oauth);

          return oauth.setReq(req).login();
        }.bind(this));
      },

      ldap: (req, options) => {
        return co(function* () {
          if (!options.ldap) {
            throw new AFError(403, 'LDAP disabled');
          }

          var ldap = new LDAP(options.ldap);
          let ldapData = yield ldap.setReq(req).login();

          if (options.oauth) {
            let role = options.ldap && options.ldap.role;
            role = role || options.defaultRole;

            let userData = {
              username: ldapData.object.uid,
              password: req.body.password,
              role: role,
              type: 'ldap',
            };

            let user = yield User.find({
              $and: [{
                $or: [
                  { username: ldapData.object.uid },
                  { username: req.body.username }
                ]
              }, {
                $or: [
                  { type: 'ldap' },
                  { type: { $exists: false } }
                ]
              }]
            }, req.application);
            user = user || (new User({}, req.application));
            yield user.update(userData);

            req.body.username = user.username;

            return Auth.login.oauth(req, options);
          }

          return ldapData.object;
        }.bind(this));
      },

      facebook: (req, options, roleId) => {
        return co(function* () {
          if (!options.facebook) {
            throw req.params.auth_method ? new AFError(403, 'Facebook disabled') : undefined;
          }

          let facebook = new Facebook(options.facebook);

          let facebookData = yield facebook.setReq(req).login();
          if (!options.oauth) return facebookData;

          req.request.fields.username = facebookData.id;
          req.request.fields.password = 'FacebookPassword';

          try {
            yield Auth.login.oauth(req, options);
          } catch (err) {
            if (err.message == 'Invalid clientSecret') {
              throw err;
            }
          }

          let role = options.facebook && options.facebook.role;
          role = role || options.defaultRole || roleId;

          let user = yield User.find({
            username: req.request.fields.username,
            type: 'facebook'
          }, {}, req.application.id);

          if (!user) {
            user = new User({
              username: req.request.fields.username,
              password: User.cryptPassword(req.request.fields.password),
              role: role,
              type: 'facebook',
            }, req.application.id);
          } else {
            user.password = req.request.fields.password;
          }

          try {
            yield user.save();
          } catch (e) { }

          return Auth.login.oauth(req, options);
        }.bind(this));
      },

      vk: (req, options, roleId) => {
        return co(function* () {
          if (!options.vk) {
            throw req.params.auth_method ? new AFError(403, 'VK disabled') : undefined;
          }

          let vk = new VK(options.vk);

          let vkData = yield vk.setReq(req).login();
          if (!options.oauth) return vkData;

          req.request.fields.username = vkData.id;
          req.request.fields.password = 'VKPassword';

          try {
            yield Auth.login.oauth(req, options);
          } catch (err) {
            if (err.message == 'Invalid clientSecret') {
              throw err;
            }
          }

          let role = options.vk && options.vk.role;
          role = role || options.defaultRole || roleId;

          let user = yield User.find({
            username: req.request.fields.username,
            type: 'vk'
          }, {}, req.application.id);

          if (!user) {
            user = new User({
              username: req.request.fields.username,
              password: User.cryptPassword(req.request.fields.password),
              role: role,
              type: 'vk',
            }, req.application.id);
          } else {
            user.password = req.request.fields.password;
          }

          try {
            yield user.save();
          } catch (e) { }

          return Auth.login.oauth(req, options);
        }.bind(this));
      },

      ok: (req, options, roleId) => {
        return co(function* () {
          if (!options.ok) {
            throw req.params.auth_method ? new AFError(403, 'OK disabled') : undefined;
          }

          let ok = new OK(options.ok);

          let okData = yield ok.setReq(req).login();
          if (!options.oauth) return okData;

          req.request.fields.username = okData.id;
          req.request.fields.password = 'OKPassword';

          try {
            yield Auth.login.oauth(req, options);
          } catch (err) {
            if (err.message == 'Invalid clientSecret') {
              throw err;
            }
          }

          let role = options.ok && options.ok.role;
          role = role || options.defaultRole || roleId;

          let user = yield User.find({
            username: req.request.fields.username,
            type: 'ok'
          }, {}, req.application.id);

          if (!user) {
            user = new User({
              username: req.request.fields.username,
              password: User.cryptPassword(req.request.fields.password),
              role: role,
              type: 'ok',
            }, req.application.id);
          } else {
            user.password = req.request.fields.password;
          }

          try {
            yield user.save();
          } catch (e) { }

          return Auth.login.oauth(req, options);
        }.bind(this));
      },
    };
  }

  static get logout() {
    return {
      oauth: (req, options) => {
        if (!options.oauth) {
          return Promise.reject(new AFError(403, 'OAuth disabled'));
        }

        var oauth = new OAuth(options.oauth);

        return oauth.setReq(req).logout();
      },
      
      oauth2: (req, options) => {
        if (!options.oauth) {
          return Promise.reject(new AFError(403, 'OAuth disabled'));
        }

        var oauth = new OAuth2(options.oauth);

        return oauth.setReq(req).logout();
      },

      ldap: (req, options) => {
        if (!options.ldap) {
          return Promise.reject(new AFError(403, 'LDAP disabled'));
        }

        var ldap = new LDAP(options.ldap);

        return ldap.setReq(req).logout();
      }
    };
  }

  static get refresh() {
    return {
      oauth: (req, options) => {
        if (!options.oauth) {
          return Promise.reject(new AFError(403, 'OAuth disabled'));
        }

        var oauth = new OAuth(options.oauth);

        return oauth.setReq(req).refresh();
      },
      oauth2: (req, options) => {
        if (!options.oauth) {
          return Promise.reject(new AFError(403, 'OAuth disabled'));
        }

        var oauth = new OAuth2(options.oauth);

        return oauth.setReq(req).refresh();
      }
    };
  }
}

module.exports = Auth;
